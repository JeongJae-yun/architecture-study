## MVVM?
<image width="350" height="300" src="https://user-images.githubusercontent.com/55985789/92194253-3128e680-eea5-11ea-804f-b365544bd2f7.png"/>           

- MVVM 패턴이란 Model, View, ViewModel의 줄임말. 
- 가장 기능적으로 작게 만들어서 테스트가 쉽고 유지보수가 쉽다. 
- MVP가 1:1관계로 늘어난다면 MVVM은 뷰모델 재사용이 가능해서 1:N 관계로 확장이 가능하다. 
- 하나의 뷰모델을 여러개의 뷰에 넣을수 있다.
- 모든 input에 대해 뷰는 로직을 처리할 뷰모델에 전달하고 뷰모델은 로직 처리를 위해 모델의 데이터에 엑세스 하거나 로직을 처리 한 후, 반환한다.
- 이때 중요한점은 뷰모델은 뷰를 알 필요가 없다. 
- 즉. 뷰모델은 뷰를 따로 참조하지 않기에 1:n 관계 형성. 
- MVP가 원형임으로 mvp처럼 v-m의 의존관계는 없고 v-vm은 독립적이라 의존관계 없다.

## Test 플로우 정리. 
1. View에 입력이 들어오면 Command패턴으로 ViewModel에 명령을 함
2. ViewModel은 필요한 데이터를 Model에 요청
3. Model은 ViewModel에 필요한 데이터를 응답
4. ViewModel은 응답 받은 데이터를 가공해서 저장
5. View는 ViewModel과의 Data Binding으로 인해 자동으로 갱신


## 장점.
 - 서로간의 의존성이 없어지니 당연히 테스트가 쉽다.        
 - 테스트시에 옵저빙을 하면서 모델 변경이 일어났는지만 관찰하면 되서 mvp에서 테스트를 위해 별도의 뷰를 만든것과는 차이가 있다.      
 - databinding을 사용하여 서로간의 의존성을 더욱 낮출 수도 있다.           
  
## 단점. 
 - 뷰가 변수와 표현식 모두에 바인당 될 수 있으므로 시간 지나면 관계없는 presentation layer가 늘어날수있음. 

## 핵심. 
 - MVVM에서 뷰모델이 가장 중요하다 착각할 수 있다. 
 - 중요한 건 사실이지만 MVVM에선  뷰를 능동적이 아닌 수동적으로 만들어주는 것이 필요하다. 
 - 뷰모델이 뷰의 존재를 알지 못하게 하여 플랫폼 의존성에서 벗어나는 것!
 
 
그래서 많은 사람들이 MVVM을 데이터바인딩과 쓸때 가장 효과적이라고 한다. 
### 왜? 
- 데이터 바인딩은 뷰모델에서 데이터를 변경을 알림 주기 보다 뷰에 바인딩 시켜놓고 뷰가 매우 수동적으로 변경되어 다양한 인터렉션이 가능하고 독립적이기에. 
- 물론 모델에거 데이터 변경되면 뷰모델 거쳐서 뷰로 전달되는데까지 rxjava나 라이브데이터를 쓰기도 한다. 


## Reference
[안드로이드-아키텍쳐-패턴-MVVM이 뭘까 ](https://velog.io/@jojo_devstory/안드로이드-아키텍처-패턴-MVVM이-뭘까)         
[Android AAC를 활용한 MVVM 패턴](https://medium.com/@joongwon/android-aac를-활용한-mvvm-패턴-e24a685fc25d)



